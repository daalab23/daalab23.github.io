<!DOCTYPE html>
<html>
<head>
  <script>
    function copyToClipboard(textbox) {
        textbox.select();
        document.execCommand("copy");
      }
      function scrollToTop() {
	window.scrollTo({
	 top: 0,
	 left: 0,
	 behavior: 'smooth'
	});
      }
  </script>
</head>
<body>
	<p><h3>DAA Lab 2023 (according to the curriculum of OU for batch 2020-2024)</h3></p>
        <div>
		<!-- create the menu with links to different sections of the page -->
		<a href="#textbox5">1. Print all the nodes reachable from a given starting node in a digraph using BFS method 
and Check whether a given graph is connected or not using DFS method.</a> <br>
		<a href="#textbox7">2. Sort a given set of elements and determine the time required to sort the elements
using Quick Sort</a> <br>
		<a href="#textbox8">3. Sort a given set of elements and determine the time required to sort the elements
using Merge Sort</a> <br>
		<a href="#textbox9">4. Knapsack using Brute Force</a> <br>
		<a href="#textbox10">5. Knapsack using Greedy method</a> <br>
        <a href="#textbox11">6. Knapsack using Dynamic Programming</a> <br>
        <a href="#textbox12">7.From a given vertex in a weighted connected graph, find shortest paths to other 
vertices using Dijkstra's algorithm</a> <br>
    <p><h5>*** More programs will be added in future ***</h5></p>
    <a href="https://drive.google.com/drive/folders/1yq-I5Z71uWXyNvfWvA_1-NlKApuk6h2f" target="_blank">For outputs visit</a>
	</div>

 <!------------------------------------------------------ -->
  <div>
        <P><<h2>Print all the nodes reachable from a given starting node in a digraph using BFS method 
and Check whether a given graph is connected or not using DFS method.</h2>
  <textarea id="textbox5" rows="25" cols="100">                    
#include <stdio.h>

int cost[20][20], queue[20], front=-1, rear=-1, n;
int visited1[20], visited2[20];

void BFS() {
    int v;
    printf("Enter the initial vertex: ");
    scanf("%d", &v);
    printf("Visited vertices:\n");
    visited1[v] = 1;
    queue[++rear] = v;
    while (front != rear) {
        v = queue[++front];
        printf("%d ", v);
        for (int j = 1; j <= n; j++) {
            if (!visited1[j] && cost[v][j] == 1) {
                queue[++rear] = j;
                visited1[j] = 1;
            }
        }
    }
}

void DFS(int v) {
    visited2[v] = 1;
    for (int i = 1; i <= n; i++) {
        if (cost[v][i] && !visited2[i]) {
            printf("\n%d->%d", v, i);
            DFS(i);
        }
    }
}

int main() {
    int i, j, count=0;
    printf("Enter the number of vertices: ");
    scanf("%d", &n);
    for (i = 1; i <= n; i++) {
        visited1[i] = 0;
        visited2[i] = 0;
        for (j = 1; j <= n; j++) {
            cost[i][j] = 0;
        }
    }
    printf("\nEnter the adjacency matrix:\n");
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            scanf("%d", &cost[i][j]);
        }
    }
    
    BFS();

    DFS(1);
    for (int i = 1; i <= n; i++) {
        if (visited2[i]) {
            count++;
        }
    }
    if (count == n)
        printf("\nGraph is connected");
    else
        printf("\nGraph is NOT connected");
    
    return 0;
}
  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox5'))">Copy</button>
  <button onclick="scrollToTop()">Go to Top</button>
    <br>
  </div>
	
  <!------------------------------------------------------ -->
	  
  <div>
        <P><<h2>Sort a given set of elements and determine the time required to sort the elements
using Quick Sort</h2>
  <textarea id="textbox7" rows="25" cols="100">    
#include<stdio.h>
#include <time.h>
void QuickSort(int list[],int first,int last)
{
    int pivot,i,j,temp;
  if(first < last)
  {
    pivot = first;
    i = first;
    j = last;
    while(i < j)
    {
        while(list[i] <= list[pivot] && i < last)
            i++;
        while(list[j] > list[pivot])
            j--;
        if(i < j)
        {
            temp = list[i];
            list[i] = list[j];
            list[j] = temp;
        }
    }
    temp = list[pivot];
    list[pivot] = list[j];
    list[j] = temp;
    QuickSort(list,first,j-1);
    QuickSort(list,j+1,last);
  }
}

int main()
{
    int i, n, list[20];
    clock_t st, et;
    double ts;
    printf("enter no of elements: ");
    scanf("%d",&n);
    printf("enter elements\n");
    for(i=0;i<n; i++)
    {
        scanf("%d",&list[i]);
    }
    st = clock(); // Start the timer
    QuickSort(list,0,n-1);
    et = clock(); // Stop the timer
    ts = (double)(et - st) / CLOCKS_PER_SEC;
    printf("after sorting the array: ");
    for(i=0; i<n; i++)
    {
        printf("%d ",list[i]);
    }
    printf("\nThe time taken is %f sec", ts);
}


  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox7'))">Copy</button>
  <button onclick="scrollToTop()">Go to Top</button>
    <br>
  </div>
	  
 <!------------------------------------------------------ -->
	  
  <div>
        <P><<h2>Sort a given set of elements and determine the time required to sort the elements
using Merge Sort</h2>
  <textarea id="textbox8" rows="25" cols="100">    
#include <stdio.h>
#include <time.h>
void Merge(int a[], int low, int mid, int high)
{
    // We have low to mid and mid+1 to high already sorted.
    int i, j, k, temp[high - low + 1];
    i = low;     // index of first element in first half
    k = 0;       // index of temporary array temp
    j = mid + 1; // index of first element in second half
    // Merge the two parts into temp[].
    while (i <= mid && j <= high)
    {
        if (a[i] < a[j])
        {
            temp[k] = a[i];
            k++;
            i++;
        }
        else
        {
            temp[k] = a[j];
            k++;
            j++;
        }
    }
    // Insert all the remaining values from i to mid into temp[].
    while (i <= mid)
    {
        temp[k] = a[i];
        k++;
        i++;
    }
    // Insert all the remaining values from j to high into temp[].
    while (j <= high)
    {
        temp[k] = a[j];
        k++;
        j++;
    }
    // Assign sorted data stored in temp[] to a[].
    for (i = low; i <= high; i++)
    {
        a[i] = temp[i - low];
    }
}
// A function to split array into two parts.
void MergeSort(int a[], int low, int high)
{
    int mid;
    if (low < high) // array is having more than one element
    {
        mid = (low + high) / 2;
        // Split the data into two half.
        MergeSort(a, low, mid); // applying mergesort on first half
        MergeSort(a, mid + 1, high);
        // Merge them to get sorted output
        Merge(a, low, mid, high);
    }
}
void main()
{
    int i, n, a[50];
    clock_t st, et;
    double ts;
    printf("Enter How many Numbers: ");
    scanf("%d", &n);
    printf("Enter elements in array:\n");
    for(i=0;i<n;i++) {
        scanf("%d", &a[i]);
    }
    st = clock(); // Start the timer
    MergeSort(a, 0, n - 1);
    et = clock(); // Stop the timer
    ts = (double)(et - st) / CLOCKS_PER_SEC;
    printf("\nAfter sorting the array:\n");
    for (i = 0; i < n; i++) {
        printf("%d ", a[i]);
    }
    printf("\nThe time taken is %f sec", ts);
}

  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox8'))">Copy</button>
  <button onclick="scrollToTop()">Go to Top</button>
    <br>
  </div>
  
   <!------------------------------------------------------ -->
	  
  <div>
        <P><<h2>Knapsack using Brute Force</h2>
  <textarea id="textbox9" rows="25" cols="100">    
#include <stdio.h>
int n, cap;
int w[100], v[100];
int max_value = 0;

void knapsack(int i, int weight, int value) {
    if (i == n) { // base case: no more items to consider
        if (weight <= cap && value > max_value) { // check if this solution is better than previous ones
            max_value = value; // update maximum value
        }
        return;
    }
    knapsack(i + 1, weight + w[i], value + v[i]); // add current item to knapsack
    knapsack(i + 1, weight, value); // do not add current item to knapsack
}

int main() {
    printf("Enter the number of items: ");
    scanf("%d", &n);
    printf("Enter the capacity of the knapsack: ");
    scanf("%d", &cap);
    printf("Enter the weight and value of each item:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d%d", &w[i], &v[i]);
    }
    knapsack(0, 0, 0); // start with empty knapsack
    printf("Maximum value: %d\n", max_value);
    return 0;
}

  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox9'))">Copy</button>
  <button onclick="scrollToTop()">Go to Top</button>
    <br>
  </div>	  
	  
  <!------------------------------------------------------ -->
	  
  <div>
        <P><<h2>Knapsack using Greedy method</h2>
  <textarea id="textbox10" rows="25" cols="100">    
# include<stdio.h>
 
void knapsack(int n, float weight[], float profit[], float capacity) {
   float x[20], tp = 0;
   int i, j, u;
   u = capacity;
 
   for (i = 0; i < n; i++)
      x[i] = 0.0;
 
   for (i = 0; i < n; i++) {
      if (weight[i] > u)
         break;
      else {
         x[i] = 1.0;
         tp = tp + profit[i];
         u = u - weight[i];
      }
   }
 
   if (i < n)
      x[i] = u / weight[i];
 
   tp = tp + (x[i] * profit[i]);
 
   printf("\nThe result vector is:- ");
   for (i = 0; i < n; i++)
      printf("%f\t", x[i]);
 
   printf("\nMaximum profit is:- %f", tp);
 
}
 
int main() {
   float weight[20], profit[20], capacity;
   int num, i, j;
   float ratio[20], temp;
 
   printf("\nEnter the no. of objects:- ");
   scanf("%d", &num);
 
   printf("\nEnter the wts and profits of each object:- ");
   for (i = 0; i < num; i++) {
      scanf("%f %f", &weight[i], &profit[i]);
   }
 
   printf("\nEnter the capacityacity of knapsack:- ");
   scanf("%f", &capacity);
 
   for (i = 0; i < num; i++) {
      ratio[i] = profit[i] / weight[i];
   }
 
   for (i = 0; i < num; i++) {
      for (j = i + 1; j < num; j++) {
         if (ratio[i] < ratio[j]) {
            temp = ratio[j];
            ratio[j] = ratio[i];
            ratio[i] = temp;
 
            temp = weight[j];
            weight[j] = weight[i];
            weight[i] = temp;
 
            temp = profit[j];
            profit[j] = profit[i];
            profit[i] = temp;
         }
      }
   }
 
   knapsack(num, weight, profit, capacity);
   return(0);
}
  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox10'))">Copy</button>
  <button onclick="scrollToTop()">Go to Top</button>
    <br>
  </div>

  <!------------------------------------------------------ -->
	  
  <div>
        <P><<h2>Knapsack using Dynamic Programming</h2>
  <textarea id="textbox11" rows="25" cols="100">    
#include <stdio.h>
int w[10], p[10], v[10][10], n, i, j, cap, x[10] = {0};
int max(int i, int j)
{
    return ((i > j) ? i : j);
}
int knap(int i, int j)
{
    int value;
    if (v[i][j] < 0)
    {
        if (j < w[i])
            value = knap(i - 1, j);
        else
            value = max(knap(i - 1, j), p[i] + knap(i - 1, j - w[i]));
        v[i][j] = value;
    }
    return (v[i][j]);
}
void main()
{
    int profit, count = 0;
    printf("\nEnter the number of elements\n");
    scanf("%d", &n);
    printf("Enter the profit and weights of the elements\n");
    for (i = 1; i <= n; i++)
    {
        printf("For item no %d\n", i);
        scanf("%d%d", &p[i], &w[i]);
    }
    printf("\nEnter the capacity \n");
    scanf("%d", &cap);
    for (i = 0; i <= n; i++)
        for (j = 0; j <= cap; j++)
            if ((i == 0) || (j == 0))
                v[i][j] = 0;
            else
                v[i][j] = -1;
    profit = knap(n, cap);
    i = n;
    j = cap;
    while (j != 0 && i != 0)
    {
        if (v[i][j] != v[i - 1][j])
        {
            x[i] = 1;
            j = j - w[i];
            i--;
        }
        else
            i--;
    }
    printf("Items included are\n");
    printf("Sl.no\tweight\tprofit\n");
    for (i = 1; i <= n; i++)
        if (x[i])
            printf("%d\t%d\t%d\n", ++count, w[i], p[i]);
    printf("Total profit = %d\n", profit);
}

  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox11'))">Copy</button>
  <button onclick="scrollToTop()">Go to Top</button>
    <br>
  </div>  	

  <!------------------------------------------------------ -->
	  
  <div>
        <P><<h2>From a given vertex in a weighted connected graph, find shortest paths to other 
vertices using Dijkstra's algorithm</h2>
  <textarea id="textbox12" rows="25" cols="100">    
#include <stdio.h>
#define infinity 999
void dijkstra(int n, int v, int cost[10][10], int dist[100])
{
    int i, u, count, w, flag[10], min;
    for (i = 1; i <= n; i++){
        flag[i] = 0, dist[i] = cost[v][i];
    }
    count = 2;
    while (count <= n)
    {
        min = 99;
        for (w = 1; w <= n; w++){
            if (dist[w] < min && !flag[w])
                min = dist[w], u = w;
        }
        flag[u] = 1;
        count++;
        for (w = 1; w <= n; w++){
            if ((dist[u] + cost[u][w] < dist[w]) && !flag[w])
                dist[w] = dist[u] + cost[u][w];
        }
    }
}
void main()
{
    int n, v, i, j, cost[10][10], dist[10];
    printf("\n Enter the number of nodes:");
    scanf("%d", &n);
    printf("\n Enter the cost matrix:\n");
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++)
        {
            scanf("%d", &cost[i][j]);
            if (cost[i][j] == 0)
                cost[i][j] = infinity;
        }
    }
    printf("\n Enter the source Vertex:");
    scanf("%d", &v);
    dijkstra(n, v, cost, dist);
    printf("\n Shortest path:\n");
    for (i = 1; i <= n; i++){ 
        if (i != v) {
            printf("%d->%d,cost=%d\n", v, i, dist[i]);
        }
    }
}


  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox12'))">Copy</button>
  <button onclick="scrollToTop()">Go to Top</button>
    <br>
  </div>  
	  
	  
</body>
</html>
